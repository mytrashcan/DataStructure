# 빅오 표기법

- 알고리즘의 일반적인 증가추세에 중점 -> 불필요한 정보(최고차항을 제외한 항)를 제거
- 함수값을 결정하는 가장 중요한 최고차항만 표시하여 함수의 수행시간을 대략적으로 표현하는 방법
- n의 값에 따른 함수의 상한값을 나타내는 방법

## 목적
- 서로 다른 알고리즘을 성능 기준으로 비교할 때 사용
- 하드웨어나 프로그래밍 언어, 구현 방식에 따라 달라질 수 있는 절대적인 수행 시간 대신, 
  성장률(Growth rate) 중심으로 분석
- 알고리즘의 대략적인 수행시간을 추정할 수 있음

## 표기 방법
1. 수행 시간 또는 공간 복잡도를 나타내는 함수 T(n)에서
   상수 계수 및 최고차항 이외의 항을 제거 (다만, log n은 없애버리면 안 된다.)
2. 남은 최고차항의 차수를 기준으로 O(차수) 형태로 표기

### 예시
```
$T(n) = 7n - 2       →   O(n)$  
$T(n) = n^2 + n + 1  →   O(n²) $  
$T(n) = 8n² \log n + 5n² + n  →  O(n² \log n)$  
```
- $n^2$은 입력 크기 $n$이 증가함에 따라 가장 큰 영향을 주므로 나머지 항은 생략

### 빅오 표기법에 의한 알고리즘의 수행시간 비교
$O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!)$

| 복잡도     | 이름       | 예시 알고리즘                     |
| ------- |----------| --------------------------- |
| $O(1)$  | 상수 시간    | 해시 테이블 검색, 배열 인덱스 접근        |
| $O(\log n)$ | 로그 시간    | 이진 탐색                       |
| $O(n)$  | 선형 시간    | 선형 탐색                       |
| $O(n \log n)$ | 선형-로그 시간 | 병합 정렬, 퀵 정렬 평균              |
| $O(n^2)$ | 이차 시간    | 버블 정렬, 삽입 정렬                |
| $O(2^n)$ | 지수 시간    | 일부 완전 탐색                    |
| $O(n!)$ | 팩토리얼 시간  | 순열 생성, 외판원 문제 (Brute force) |


---

# 빅오 표기법 이외의 표기법
- 빅오 표기법은 상한을 표기한 것이므로 상한은 여러 개가 존재할 수 있다
- 따라서 이와 같은 문제점을 보완하기 위하여 빅오메가와 빅쎄타 표기법이 있다.  

빅오 표기법: 두 개의 함수 $f(n)$과 $g(n)$이 주어졌을 때 모든 $n>n_0$에 대하여 $|f(n)|<=c|g(n)|$
을 만족하는 2개의 상수 $c$와 $n_0$가 존재하면 $f(n) = O(g(n))$이다.  

$f(n) = 2n +1$ 에서 $f(n) = O(n)$이라 하였지만 $f(n) = O(n^2)$라고도 할 수 있다.  
$n_0 = 1, c = 2$로 잡으면 $n>1$에 대하여 $2n+1 <= 2n^2$이기 때문이다.

## 빅오메가 표기법
두 개의 함수 $f(n)$과 $g(n)$이 주어졌을 때 모든 $n>n_0$에 대하여 $|f(n)|>=c|g(n)|$
 을 만족하는 2개의 상수 $c$와 $n_0$가 존재하면 $f(n) = \Omega(g(n))$이다.

## 빅쎄타 표기법
두 개의 함수 $f(n)$과 $g(n)$이 주어졌을 때 모든 $n>n_0$에 대하여 $c_1|g(n)|<=|f(n)|<=c_2|g(n)|$
을 만족하는 2개의 상수 $c$와 $n_0$가 존재하면 $f(n) = \Theta(g(n))$이다.

---

# 최선, 평균, 최악의 경우
똑같은 알고리즘도 주어지는 입력의 집합에 따라 다른 수행 시간을 보일 수 있다.  
그러면 알고리즘의 수행 시간을 이야기할 때 어떤 자료 집합을 기준으로 해야 할까?
- 알고리즘의 효율성은 주어지는 자료집합에 따라 다음의 3가지 경우로 나누어서 평가할 수 있다.

## 1. 최악(worst case)
자료집합 중에서 알고리즘의 수행시간이 가장 오래 걸리는 경우  
시간 복잡도 분석 시 가장 일반적으로 사용
## 2. 최선(best case)
자료집합 중에서 알고리즘의 수행시간이 가장 빠른 경우
## 3. 평균(average case)
알고리즘의 모든 입력을 고려하고 각 입력이 발생하는 확률을 고려한 수행시간

