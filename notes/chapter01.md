# 알고리즘 복잡도 분석 방법

- 코드를 구현하지 않고도 **모든 입력을 고려하는** 방법이다.
- 실행 하드웨어나 소프트웨어 환경과는 관계없이 **알고리즘의 효율성 평가**가 가능하다.

---

## 시간 복잡도 함수

- 알고리즘 분석에서 ‘좋다’는 의미는 **수행 시간**, 즉 *시간 복잡도(Time Complexity)*를 말함.
- 시간 복잡도는 알고리즘의 절대적인 수행 시간이 아니라, **알고리즘을 이루는 연산이 몇 번 수행되는지**를 분석하는 것이다.

> 예시  
> 알고리즘 1 (기본 연산 수 20),  
> 알고리즘 2 (기본 연산 수 100)  
> → **알고리즘 1이 더 효율적인 알고리즘**이라 할 수 있음.

- 그런데 연산들의 수행 횟수는 보통 상수가 아니다.
- 입력의 크기 `n`에 따라 변하므로, 일반적으로 연산의 수행 횟수는 **입력 크기 `n`에 대한 함수**, 즉 `T(n)`으로 표현한다.

---

##  예제: 양의 정수 `n`을 `n`번 더하는 문제

###  알고리즘 A (한 줄 계산)

```plaintext
sum <- n * n
```

###  알고리즘 B (반복문으로 더함)

```plaintext
for i ← 1 to n do
    sum ← sum + n
```

###  알고리즘 C (중첩 반복문으로 더함)

```plaintext
for i ← 1 to n do
    for j ← 1 to n do
        sum ← sum + 1
```
### 알고리즘의 비교
|       | 알고리즘 A | 알고리즘 B | 알고리즘 C |
|-------|--------|--------|--------|
| 대입연산  | 1      | n      | n * n  |
| 덧셈연산  |        | n      | n * n  |
| 곱셈연산  | 1      |        |        |
| 나눗셈연산 |        |        |        |
| 전체연산수 | 2      | 2n     | 2n<sup>2  |

